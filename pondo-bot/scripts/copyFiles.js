const fs = require('fs');
const path = require('path');

// Source files
const filesToCopy = [
  '../multi_token_support_program/build/main.aleo',
  '../pondo/pondo_core_protocol/build/main.aleo',
  '../pondo/pondo_oracle/build/main.aleo',
  '../pondo/pondo_staked_aleo_token/build/main.aleo',
  '../pondo/pondo_token/build/main.aleo',
  '../pondo/reference_delegator/build/main.aleo',
  '../pondo/delegators/pondo_delegator1/build/main.aleo',
  '../pondo/delegators/pondo_delegator2/build/main.aleo',
  '../pondo/delegators/pondo_delegator3/build/main.aleo',
  '../pondo/delegators/pondo_delegator4/build/main.aleo',
  '../pondo/delegators/pondo_delegator5/build/main.aleo'
];

// Ensure the target directory exists
const targetDir = './programs';
if (!fs.existsSync(targetDir)) {
  fs.mkdirSync(targetDir, { recursive: true });
}

// Function to parse program name from a file
const parseProgramName = (filePath) => {
  const content = fs.readFileSync(filePath, 'utf8');
  const lines = content.split('\n');

  for (let line of lines) {
    if (line.startsWith('program ')) {
      const parts = line.split(' ');
      if (parts.length >= 2) {
        return parts[1].replace(';', '');
      }
    }
  }

  throw new Error(`Program name not found in ${filePath}`);
};

// Copy each file to the target directory with the calculated name
const pondoProgramToCode = {};
filesToCopy.forEach(fileSrc => {
  const programName = parseProgramName(fileSrc);
  const fileDest = path.join(targetDir, programName);
  const fileContent = fs.readFileSync(fileSrc, 'utf8');
  pondoProgramToCode[programName] = fileContent;
  fs.copyFileSync(fileSrc, fileDest);
  console.log(`Copied ${fileSrc} to ${fileDest}`);
});

// Function to parse dependencies from a program file
const parseDependencies = (filePath) => {
  const content = fs.readFileSync(filePath, 'utf8');
  const lines = content.split('\n');
  const dependencies = [];

  lines.forEach(line => {
    if (line.startsWith('import ')) {
      const parts = line.split(' ');
      if (parts.length >= 2) {
        const dependency = parts[1].replace(';', '');
        dependencies.push(dependency);
      }
    }
  });

  return dependencies;
};

// Parse dependencies and create the dependency tree
const dependencyTree = {};
filesToCopy.forEach(fileSrc => {
  const programName = parseProgramName(fileSrc);
  const dependencies = parseDependencies(fileSrc);
  dependencyTree[programName] = dependencies;
});

// Topological sort of the programs based on dependencies
const topologicalSort = (graph) => {
  const visited = {};
  const stack = [];

  const visit = (node) => {
    if (!visited[node]) {
      visited[node] = true;
      (graph[node] || []).forEach(visit);
      stack.push(node);
    }
  };

  Object.keys(graph).forEach(visit);

  return stack;
};

const sortedPrograms = topologicalSort(dependencyTree);

// Write the compiledPrograms.ts file
const compiledProgramsPath = path.join('.', 'src', 'compiledPrograms.ts');
const compiledProgramsContent = `
/*** GENERATED FILE - DO NOT EDIT ***/
/*** This is generated by the copyFiles.js script ***/

export const pondoPrograms = ${JSON.stringify(sortedPrograms, null, 2)};

export const pondoDependencyTree: { [key: string]: string[] } = ${JSON.stringify(dependencyTree, null, 2)};

export const pondoProgramToCode: { [key: string]: string } = ${JSON.stringify(pondoProgramToCode, null, 2)};
`;

fs.writeFileSync(compiledProgramsPath, compiledProgramsContent.trim());
console.log(`Created ${compiledProgramsPath}`);